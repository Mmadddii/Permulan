---
title: "Permulan paketea"
author: "Maddi"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Permulan-tutorial}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

## Hasierako urratsak

Paketea kargatzeko:

```{r setup}
library(Permulan)
```
## Laguntza kontsultatzea

Pakete honetako funtzio guztien laguntzara **iritxi** daiteke `?funtzioa` exekutatuz.  

## Sarrera

**Permulan**  paketeak datuen aurreprozesamendurako eta azterketa estatistikorako tresna multzoa eskaintzen du.S4 klaseen bidez egituratuta dago  

## Klase nagusiak
Paketeak bi klase nagusi ditu:

+ `Atributua`: aldagai bakar baten informazioa gordetzen du (izena, mota, balioak). 
+ `DatuMultzoa`: atributu multzo bat eta aukerazko klase-aldagai bat gordetzeko.
+ Horrez gain data.frame formatua ere onartzen dute funtzio guztietan




```{r}
a <- Atributua("adina", c(21, 35, 50))
a
datuak <- data.frame(adina = c(21, 35, 50), sexua = c("M", "F", "M"))
dm <- DatuMultzoa(datuak, klase_izena = "sexua")
dm

```
## Normalizazioa eta Estandarizazioa
**`normalize()`** eta **`standardize()`** funtzioek atributu zenbakizkoak eraldatzen dituzte:

- `normalize()`:  
  Atributuak **[0, 1]** tartean eskalatzen ditu, hau da:  
  \[
  x' = \frac{x - \min(x)}{\max(x) - \min(x)}
  \]

- `standardize()`:  
  Atributuak batezbesteko **0** eta desbideratze estandar **1** duen eskalara eramaten ditu:  
  \[
  z = \frac{x - \bar{x}}{s_x}
  \]

Funtzio hauek S4 motako **`Atributua`**, eta **`DatuMultzoa`** klaseetarako funtzionatzen dut, baita **`data.frame`** datu-taulentzat eta  **`numeric`** motako bektoreentzat ere.
```{r}
#data.frame motako objektuentzat:
df <- data.frame(
  adina = c(20, 25, 30, 35, 40, 45, 50, 55, 60, 65),
  soldata = c(1200, 1500, 1600, 2000, 2300, 2600, 2800, 3100, 3500, 3900),  
  altuera = c(1.55, 1.62, 1.68, 1.70, 1.75, 1.78, 1.79, 1.80, 1.82, 1.83),  
  pisua = c(70, 68, 72, 74, 78, 79, 85, 88, 90, 92),                        
  zoriontasuna = c(8, 7, 6, 5, 5, 4, 3, 3, 2, 2))

normalize(df)
standardize(df)

```


## Diskretizazio funtzioak

Pakete honek hiru diskretizazio metodo eskaintzen ditu:

- **discretizeEW**: *Equal Width* balioak tarte berdinetan banatzen ditu.  
- **discretizeEF**: *Equal Frequency*  balioak maiztasun berdineko tarteetan banatzen ditu.
- **discretize**: ebaki-puntuak eskuz zehaztuz egiten du banaketa

### Equal Width adibidea
Irteera moduan diskretizatutako balioak eta ebaki puntuak ematen ditu
```{r}
x <- c(11.5, 10.2, 1.2, 0.5, 5.3, 20.5, 8.4)
discretizeEW(x, 5)
```
Atributu objektu batekin:
```{r}
a <- Atributua("adina", x)
discretizeEW(a, 5)

```
### Equal Frequency adibidea
```{r}
discretizeEF(x, 3)
discretizeEF(a, 3)

```
### Diskretizazioa eskuz emandako ebaki-puntuekin

```{r}
cut.points <- c(5.5, 10.5, 15.5)
discretize(x, cut.points)

#DatuMultzoa objektuarekin:
dm_disk <- discretize(dm, cut.points)
dm_disk
lapply(dm_disk@atributuak, function(a) list(izena = a@izena, mota = a@mota, balioak = head(a@balioak)))

```


## Korrelazioa eta Informazio Mutuala

**`korrelazio_matrizea()`** funtzioak datu multzo bateko aldagai guztien arteko  
**erlazio estatistikoa** kalkulatzen du.  

Funtzioak automatikoki hautatzen du erlazio mota aldagai motaren arabera:

- **Pearson korrelazioa**: bi aldagaiak zenbakizkoak direnean.  
- **Informazio mutua**: biak kategorikoak direnean.  
- Beste kasuetan (`numeric` vs `factor`), emaitza `NA` izango da.

Interpretazioa: 

- **Balio positiboak** → bi aldagaiak batera handitzen dira.  
- **Balio negatiboak** → bat handitzen denean bestea txikitzen da.  
- **0 inguruko balioak** → ez dago erlazio linealik.

```{r}
df <- data.frame(
  adina = c(20, 25, 30, 35, 40, 45, 50, 55, 60, 65),
  soldata = c(1200, 1500, 1600, 2000, 2300, 2600, 2800, 3100, 3500, 3900),  
  altuera = c(1.55, 1.62, 1.68, 1.70, 1.75, 1.78, 1.79, 1.80, 1.82, 1.83),  
  pisua = c(70, 68, 72, 74, 78, 79, 85, 88, 90, 92),                        
  zoriontasuna = c(8, 7, 6, 5, 5, 4, 3, 3, 2, 2))

kor <- korrelazio_matrizea(df)
print(kor)

```

**`Korrelazioak_irudikatu()`** funtzioak korrelazio-matrizearen heatmap bat sortzen du
kolore-eskala baten bidez.

+ Kolore gorriak: korrelazio positibo handia.

+ Kolore urdinak: korrelazio negatiboa.

+ Kolore txuriak: korrelazio txikia edo eza.

Adi! Funtzio honetan ez da Korrelazio_matrizearen outputa sartu behar, zuzenean datu gordinak baizik.
```{r}
Korrelazioak_irudikatu(df)

```

## Bariantza eta Entropia kalkulua


**`entropy()`** funtzioak **aldagai diskretu baten** (faktore edo atributu kategoriko baten)  
**entropia** kalkulatzen du, hau da, bere informazio edo **ziurgabetasun maila**.

**`entropy_by_column()`** funtzioak, berriz, dataset edo **`DatuMultzoa`** batean dauden  
atributu guztien entropia kalkulatzen du **zutabeka**.

Funtzio hauek S4 metodoak dituzte:  
`factor`, `Atributua`, `data.frame` eta `DatuMultzoa` klaseetarako.

Entropiak atributu baten balioek duten **informazio kopurua** neurtzen du.  
Formula hau erabiltzen da:

\[
H(X) = -\sum p(x) \log_2 p(x)
\]

non \(p(x)\) atributuko balio bakoitzaren **probabilitatea** den.

- **Entropia maximoa** lortzen da balio guztiak **maiztasun berdinarekin** agertzen direnean.  
- **Entropia minimoa (0)** gertatzen da **balio bakarra** dagoenean.  

Entropia, beraz, **aldagaiaren ziurgabetasun neurria** da:  
zenbat eta handiagoa izan, orduan eta informazio gehiago du aldagaiarekiko.

```{r}
f <- factor(c("A", "A", "B", "B", "C"))
entropy(f)


```
Atributu kategoriko batekin:
```{r}
b <- Atributua("sexua", factor(c("M", "F", "M", "F", "F")))
entropy(b)

```

**`var_col()`** funtzioak atributu zenbakizkoen bariantza kalkulatzen du.  
Funtzio honek `numeric`, `data.frame`, `Atributua` eta `DatuMultzoa` klaseetako objektuak onartzen ditu.  


Bariantzak datuen **banaketaren sakabanaketa** neurtzen du.  
Formula hau erabiltzen da:

\[
Var(X) = \frac{1}{n - 1} \sum_{i = 1}^{n} (x_i - \bar{x})^2
\]

non \( \bar{x} \) datu guztien *batezbestekoa* den.

Bariantza handiak adierazten du datuak **asko aldatzen direla**;  
bariantza txikiek, aldiz, **balioak oso antzekoak** direla.

Oharra: Atributua edo DatuMultzoa klaseko objektuetan, @mota == "numeric" dutenak bakarrik erabiltzen dira.Emaitzak bektore edo izenatutako lista moduan itzultzen dira, atributu bakoitzaren bariantzarekin.

```{r}
df <- data.frame(
  adina = c(20, 25, 30, 35, 40, 45, 50, 55, 60, 65),
  soldata = c(1200, 1500, 1600, 2000, 2300, 2600, 2800, 3100, 3500, 3900),  
  altuera = c(1.55, 1.62, 1.68, 1.70, 1.75, 1.78, 1.79, 1.80, 1.82, 1.83),  
  pisua = c(70, 68, 72, 74, 78, 79, 85, 88, 90, 92),                        
  zoriontasuna = c(8, 7, 6, 5, 5, 4, 3, 3, 2, 2))
bariantza<-var_col(df)
print(bariantza)

```

## AUC eta ROC analisia

**`roc_analisi()`** funtzioak atributu jarraitu baten eta klase binario baten arteko  
bereizgarritasuna ebaluatzen du, **ROC kurba** eta **AUC** (Area Under the Curve) kalkulatuz.  
**Visualizar_ROC()** funtzioak emaitzak irudikatzen ditu ditu.

- **AUC = 1** → Sailkapen perfektua.  
- **AUC = 0.5** → Ausazko sailkapena (informaziorik ez).  
- **AUC < 0.5** → Alderantzizko sailkapena.  
```{r}

df_test <- data.frame(
  balioa = c(0.1, 0.4, 0.35, 0.8, 0.9, 0.2, 0.6, 0.5, 0.7, 0.3),
  etiketa = c(FALSE, FALSE, TRUE, TRUE, TRUE, FALSE, TRUE, TRUE, TRUE, FALSE)
)

emaitza <- roc_analisi(df_test)
emaitza
```
**Irudikapena:**
- Kurba urdinak sistemaren errendimendua erakusten du.

- Diagonalean dagoen marra gorria ausazko sailkapena da (AUC = 0.5).

- Kurba zenbat eta gorago egon, orduan eta hobea da sailkapena.
```{r}

Visualizar_ROC(emaitza)
```

## Atributuen flitraketa
**`filter_metrics()`** funtzioak dataset baten atributuak **automatikoki iragazten** ditu aurrez kalkulatutako metrikak kontuan hartuta.  
Funtzio honek `data.frame` eta `DatuMultzoa` klaseetarako metodoak ditu. Helburua  **informazio gutxiko atributuak ezabatzea** da, analisia optimizatzeko.


| Metrika | Deskribapena | Aplikagarria |
|----------|---------------|--------------|
| **Bariantza minimoa** | Atributu numerikoentzat; bariantza baxua duten ezaugarriak baztertzen ditu. | Zenbakizko atributuak |
| **Entropia minimoa** | Atributu kategorikoentzat; informazio gutxiko kategoriak ezabatzen ditu. | Atrbutu kategorikoak |

  


### Parametroak

- `x`: Dataset-a (`data.frame` edo `DatuMultzoa`)
- `var_min`: Bariantza minimoa (lehenetsia `0`)
- `entropy_min`: Entropia minimoa (lehenetsia `0`)
- `auc_min`: AUC minimoa (lehenetsia `0`)
- `klase`: AUC kalkulatzeko etiketa binarioa (`data.frame`-ean bakarrik)

Bariantza filtratuz:
```{r}
df1 <- data.frame(
  konstantea = rep(5, 10),         
  aldakorra = 1:10,                
  txikia = c(1,1,2,2,1,2,1,2,1,2)  
)
var_col(df1)
# Bariantza >= 1 bakarrik duten aldagaiak gorde
filter_metrics(df1, var_min = 1)

```
Entropia filtratuz:
```{r}
df_ent <- data.frame(
  kol1 = factor(c("A", "A", "A", "A", "A")),   # Entropia = 0 (balio bakarra)
  kol2 = factor(c("A", "B", "A", "B", "A")),   # Entropia ertaina
  kol3 = factor(c("X", "Y", "Z", "X", "Y")))

entropy_by_column(df_ent)

# Aplikatu filtraketa entropiaren arabera (adib. entropy_min = 0.8)
df_ent_filtratua <- filter_metrics(df_ent, entropy_min = 0.8)
df_ent_filtratua


df_auc <- data.frame(
aldagaia = c(0.1, 0.4, 0.35, 0.8, 0.9, 0.2, 0.6, 0.5, 0.7, 0.3),
etiketa  = c(FALSE, FALSE, TRUE, TRUE, TRUE, FALSE, TRUE, TRUE, TRUE, FALSE)
)

# ROC kurba eta AUC kalkulatu

roc_ema <- roc_analisi(df_auc)
roc_ema$AUC

# Filtratu AUC minimoarekin

df_auc_filtratua <- filter_metrics(df_auc, auc_min = 0.6, klase = df_auc$etiketa)
df_auc_filtratua

```

